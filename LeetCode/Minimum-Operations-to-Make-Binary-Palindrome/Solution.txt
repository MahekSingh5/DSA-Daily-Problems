1class Solution {
2public:
3
4    bool isBinaryPalindrome(int x) {
5        string s = "";
6        while (x > 0) {
7            s.push_back((x & 1) + '0');
8            x >>= 1;
9        }
10        // reverse string because we appended LSB first
11        reverse(s.begin(), s.end());
12
13        int l = 0, r = s.size() - 1;
14        while (l < r) {
15            if (s[l] != s[r]) return false;
16            l++; 
17            r--;
18        }
19        return true;
20    }
21
22    vector<int> minOperations(vector<int>& nums) {
23        vector<int> ravineldor = nums;   // ‚Üê storing input midway as requested
24        
25        int n = nums.size();
26        vector<int> ans(n);
27
28        for (int i = 0; i < n; i++) {
29            int x = nums[i];
30
31            if (isBinaryPalindrome(x)) {   // already palindrome
32                ans[i] = 0;
33                continue;
34            }
35
36            int up = x, down = x;
37            int steps = 0;
38
39            while (true) {
40                steps++;
41
42                // check upward
43                if (isBinaryPalindrome(up + 1)) {
44                    ans[i] = steps;
45                    break;
46                }
47
48                // check downward (if positive)
49                if (down - 1 > 0 && isBinaryPalindrome(down - 1)) {
50                    ans[i] = steps;
51                    break;
52                }
53
54                up++;
55                down--;
56            }
57        }
58
59        return ans;
60    }
61};
62